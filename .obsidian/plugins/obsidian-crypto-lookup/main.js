/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source visit the plugins github repository
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/numeral/numeral.js
var require_numeral = __commonJS({
  "node_modules/numeral/numeral.js"(exports, module2) {
    (function(global, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        global.numeral = factory();
      }
    })(exports, function() {
      var numeral2, _, VERSION = "2.0.6", formats = {}, locales = {}, defaults = {
        currentLocale: "en",
        zeroFormat: null,
        nullFormat: null,
        defaultFormat: "0,0",
        scalePercentBy100: true
      }, options = {
        currentLocale: defaults.currentLocale,
        zeroFormat: defaults.zeroFormat,
        nullFormat: defaults.nullFormat,
        defaultFormat: defaults.defaultFormat,
        scalePercentBy100: defaults.scalePercentBy100
      };
      function Numeral(input, number) {
        this._input = input;
        this._value = number;
      }
      numeral2 = function(input) {
        var value, kind, unformatFunction, regexp;
        if (numeral2.isNumeral(input)) {
          value = input.value();
        } else if (input === 0 || typeof input === "undefined") {
          value = 0;
        } else if (input === null || _.isNaN(input)) {
          value = null;
        } else if (typeof input === "string") {
          if (options.zeroFormat && input === options.zeroFormat) {
            value = 0;
          } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, "").length) {
            value = null;
          } else {
            for (kind in formats) {
              regexp = typeof formats[kind].regexps.unformat === "function" ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;
              if (regexp && input.match(regexp)) {
                unformatFunction = formats[kind].unformat;
                break;
              }
            }
            unformatFunction = unformatFunction || numeral2._.stringToNumber;
            value = unformatFunction(input);
          }
        } else {
          value = Number(input) || null;
        }
        return new Numeral(input, value);
      };
      numeral2.version = VERSION;
      numeral2.isNumeral = function(obj) {
        return obj instanceof Numeral;
      };
      numeral2._ = _ = {
        numberToFormat: function(value, format, roundingFunction) {
          var locale = locales[numeral2.options.currentLocale], negP = false, optDec = false, leadingCount = 0, abbr = "", trillion = 1e12, billion = 1e9, million = 1e6, thousand = 1e3, decimal = "", neg = false, abbrForce, abs, min, max, power, int, precision, signed, thousands, output;
          value = value || 0;
          abs = Math.abs(value);
          if (numeral2._.includes(format, "(")) {
            negP = true;
            format = format.replace(/[\(|\)]/g, "");
          } else if (numeral2._.includes(format, "+") || numeral2._.includes(format, "-")) {
            signed = numeral2._.includes(format, "+") ? format.indexOf("+") : value < 0 ? format.indexOf("-") : -1;
            format = format.replace(/[\+|\-]/g, "");
          }
          if (numeral2._.includes(format, "a")) {
            abbrForce = format.match(/a(k|m|b|t)?/);
            abbrForce = abbrForce ? abbrForce[1] : false;
            if (numeral2._.includes(format, " a")) {
              abbr = " ";
            }
            format = format.replace(new RegExp(abbr + "a[kmbt]?"), "");
            if (abs >= trillion && !abbrForce || abbrForce === "t") {
              abbr += locale.abbreviations.trillion;
              value = value / trillion;
            } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === "b") {
              abbr += locale.abbreviations.billion;
              value = value / billion;
            } else if (abs < billion && abs >= million && !abbrForce || abbrForce === "m") {
              abbr += locale.abbreviations.million;
              value = value / million;
            } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === "k") {
              abbr += locale.abbreviations.thousand;
              value = value / thousand;
            }
          }
          if (numeral2._.includes(format, "[.]")) {
            optDec = true;
            format = format.replace("[.]", ".");
          }
          int = value.toString().split(".")[0];
          precision = format.split(".")[1];
          thousands = format.indexOf(",");
          leadingCount = (format.split(".")[0].split(",")[0].match(/0/g) || []).length;
          if (precision) {
            if (numeral2._.includes(precision, "[")) {
              precision = precision.replace("]", "");
              precision = precision.split("[");
              decimal = numeral2._.toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
            } else {
              decimal = numeral2._.toFixed(value, precision.length, roundingFunction);
            }
            int = decimal.split(".")[0];
            if (numeral2._.includes(decimal, ".")) {
              decimal = locale.delimiters.decimal + decimal.split(".")[1];
            } else {
              decimal = "";
            }
            if (optDec && Number(decimal.slice(1)) === 0) {
              decimal = "";
            }
          } else {
            int = numeral2._.toFixed(value, 0, roundingFunction);
          }
          if (abbr && !abbrForce && Number(int) >= 1e3 && abbr !== locale.abbreviations.trillion) {
            int = String(Number(int) / 1e3);
            switch (abbr) {
              case locale.abbreviations.thousand:
                abbr = locale.abbreviations.million;
                break;
              case locale.abbreviations.million:
                abbr = locale.abbreviations.billion;
                break;
              case locale.abbreviations.billion:
                abbr = locale.abbreviations.trillion;
                break;
            }
          }
          if (numeral2._.includes(int, "-")) {
            int = int.slice(1);
            neg = true;
          }
          if (int.length < leadingCount) {
            for (var i = leadingCount - int.length; i > 0; i--) {
              int = "0" + int;
            }
          }
          if (thousands > -1) {
            int = int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1" + locale.delimiters.thousands);
          }
          if (format.indexOf(".") === 0) {
            int = "";
          }
          output = int + decimal + (abbr ? abbr : "");
          if (negP) {
            output = (negP && neg ? "(" : "") + output + (negP && neg ? ")" : "");
          } else {
            if (signed >= 0) {
              output = signed === 0 ? (neg ? "-" : "+") + output : output + (neg ? "-" : "+");
            } else if (neg) {
              output = "-" + output;
            }
          }
          return output;
        },
        stringToNumber: function(string) {
          var locale = locales[options.currentLocale], stringOriginal = string, abbreviations = {
            thousand: 3,
            million: 6,
            billion: 9,
            trillion: 12
          }, abbreviation, value, i, regexp;
          if (options.zeroFormat && string === options.zeroFormat) {
            value = 0;
          } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, "").length) {
            value = null;
          } else {
            value = 1;
            if (locale.delimiters.decimal !== ".") {
              string = string.replace(/\./g, "").replace(locale.delimiters.decimal, ".");
            }
            for (abbreviation in abbreviations) {
              regexp = new RegExp("[^a-zA-Z]" + locale.abbreviations[abbreviation] + "(?:\\)|(\\" + locale.currency.symbol + ")?(?:\\))?)?$");
              if (stringOriginal.match(regexp)) {
                value *= Math.pow(10, abbreviations[abbreviation]);
                break;
              }
            }
            value *= (string.split("-").length + Math.min(string.split("(").length - 1, string.split(")").length - 1)) % 2 ? 1 : -1;
            string = string.replace(/[^0-9\.]+/g, "");
            value *= Number(string);
          }
          return value;
        },
        isNaN: function(value) {
          return typeof value === "number" && isNaN(value);
        },
        includes: function(string, search) {
          return string.indexOf(search) !== -1;
        },
        insert: function(string, subString, start) {
          return string.slice(0, start) + subString + string.slice(start);
        },
        reduce: function(array, callback) {
          if (this === null) {
            throw new TypeError("Array.prototype.reduce called on null or undefined");
          }
          if (typeof callback !== "function") {
            throw new TypeError(callback + " is not a function");
          }
          var t = Object(array), len = t.length >>> 0, k = 0, value;
          if (arguments.length === 3) {
            value = arguments[2];
          } else {
            while (k < len && !(k in t)) {
              k++;
            }
            if (k >= len) {
              throw new TypeError("Reduce of empty array with no initial value");
            }
            value = t[k++];
          }
          for (; k < len; k++) {
            if (k in t) {
              value = callback(value, t[k], k, t);
            }
          }
          return value;
        },
        multiplier: function(x) {
          var parts = x.toString().split(".");
          return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);
        },
        correctionFactor: function() {
          var args = Array.prototype.slice.call(arguments);
          return args.reduce(function(accum, next) {
            var mn = _.multiplier(next);
            return accum > mn ? accum : mn;
          }, 1);
        },
        toFixed: function(value, maxDecimals, roundingFunction, optionals) {
          var splitValue = value.toString().split("."), minDecimals = maxDecimals - (optionals || 0), boundedPrecision, optionalsRegExp, power, output;
          if (splitValue.length === 2) {
            boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
          } else {
            boundedPrecision = minDecimals;
          }
          power = Math.pow(10, boundedPrecision);
          output = (roundingFunction(value + "e+" + boundedPrecision) / power).toFixed(boundedPrecision);
          if (optionals > maxDecimals - boundedPrecision) {
            optionalsRegExp = new RegExp("\\.?0{1," + (optionals - (maxDecimals - boundedPrecision)) + "}$");
            output = output.replace(optionalsRegExp, "");
          }
          return output;
        }
      };
      numeral2.options = options;
      numeral2.formats = formats;
      numeral2.locales = locales;
      numeral2.locale = function(key) {
        if (key) {
          options.currentLocale = key.toLowerCase();
        }
        return options.currentLocale;
      };
      numeral2.localeData = function(key) {
        if (!key) {
          return locales[options.currentLocale];
        }
        key = key.toLowerCase();
        if (!locales[key]) {
          throw new Error("Unknown locale : " + key);
        }
        return locales[key];
      };
      numeral2.reset = function() {
        for (var property in defaults) {
          options[property] = defaults[property];
        }
      };
      numeral2.zeroFormat = function(format) {
        options.zeroFormat = typeof format === "string" ? format : null;
      };
      numeral2.nullFormat = function(format) {
        options.nullFormat = typeof format === "string" ? format : null;
      };
      numeral2.defaultFormat = function(format) {
        options.defaultFormat = typeof format === "string" ? format : "0.0";
      };
      numeral2.register = function(type, name, format) {
        name = name.toLowerCase();
        if (this[type + "s"][name]) {
          throw new TypeError(name + " " + type + " already registered.");
        }
        this[type + "s"][name] = format;
        return format;
      };
      numeral2.validate = function(val, culture) {
        var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, localeData, temp;
        if (typeof val !== "string") {
          val += "";
          if (console.warn) {
            console.warn("Numeral.js: Value is not string. It has been co-erced to: ", val);
          }
        }
        val = val.trim();
        if (!!val.match(/^\d+$/)) {
          return true;
        }
        if (val === "") {
          return false;
        }
        try {
          localeData = numeral2.localeData(culture);
        } catch (e) {
          localeData = numeral2.localeData(numeral2.locale());
        }
        _currSymbol = localeData.currency.symbol;
        _abbrObj = localeData.abbreviations;
        _decimalSep = localeData.delimiters.decimal;
        if (localeData.delimiters.thousands === ".") {
          _thousandSep = "\\.";
        } else {
          _thousandSep = localeData.delimiters.thousands;
        }
        temp = val.match(/^[^\d]+/);
        if (temp !== null) {
          val = val.substr(1);
          if (temp[0] !== _currSymbol) {
            return false;
          }
        }
        temp = val.match(/[^\d]+$/);
        if (temp !== null) {
          val = val.slice(0, -1);
          if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
            return false;
          }
        }
        _thousandRegEx = new RegExp(_thousandSep + "{2}");
        if (!val.match(/[^\d.,]/g)) {
          _valArray = val.split(_decimalSep);
          if (_valArray.length > 2) {
            return false;
          } else {
            if (_valArray.length < 2) {
              return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx);
            } else {
              if (_valArray[0].length === 1) {
                return !!_valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
              } else {
                return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
              }
            }
          }
        }
        return false;
      };
      numeral2.fn = Numeral.prototype = {
        clone: function() {
          return numeral2(this);
        },
        format: function(inputString, roundingFunction) {
          var value = this._value, format = inputString || options.defaultFormat, kind, output, formatFunction;
          roundingFunction = roundingFunction || Math.round;
          if (value === 0 && options.zeroFormat !== null) {
            output = options.zeroFormat;
          } else if (value === null && options.nullFormat !== null) {
            output = options.nullFormat;
          } else {
            for (kind in formats) {
              if (format.match(formats[kind].regexps.format)) {
                formatFunction = formats[kind].format;
                break;
              }
            }
            formatFunction = formatFunction || numeral2._.numberToFormat;
            output = formatFunction(value, format, roundingFunction);
          }
          return output;
        },
        value: function() {
          return this._value;
        },
        input: function() {
          return this._input;
        },
        set: function(value) {
          this._value = Number(value);
          return this;
        },
        add: function(value) {
          var corrFactor = _.correctionFactor.call(null, this._value, value);
          function cback(accum, curr, currI, O) {
            return accum + Math.round(corrFactor * curr);
          }
          this._value = _.reduce([this._value, value], cback, 0) / corrFactor;
          return this;
        },
        subtract: function(value) {
          var corrFactor = _.correctionFactor.call(null, this._value, value);
          function cback(accum, curr, currI, O) {
            return accum - Math.round(corrFactor * curr);
          }
          this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;
          return this;
        },
        multiply: function(value) {
          function cback(accum, curr, currI, O) {
            var corrFactor = _.correctionFactor(accum, curr);
            return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
          }
          this._value = _.reduce([this._value, value], cback, 1);
          return this;
        },
        divide: function(value) {
          function cback(accum, curr, currI, O) {
            var corrFactor = _.correctionFactor(accum, curr);
            return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
          }
          this._value = _.reduce([this._value, value], cback);
          return this;
        },
        difference: function(value) {
          return Math.abs(numeral2(this._value).subtract(value).value());
        }
      };
      numeral2.register("locale", "en", {
        delimiters: {
          thousands: ",",
          decimal: "."
        },
        abbreviations: {
          thousand: "k",
          million: "m",
          billion: "b",
          trillion: "t"
        },
        ordinal: function(number) {
          var b = number % 10;
          return ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        },
        currency: {
          symbol: "$"
        }
      });
      (function() {
        numeral2.register("format", "bps", {
          regexps: {
            format: /(BPS)/,
            unformat: /(BPS)/
          },
          format: function(value, format, roundingFunction) {
            var space = numeral2._.includes(format, " BPS") ? " " : "", output;
            value = value * 1e4;
            format = format.replace(/\s?BPS/, "");
            output = numeral2._.numberToFormat(value, format, roundingFunction);
            if (numeral2._.includes(output, ")")) {
              output = output.split("");
              output.splice(-1, 0, space + "BPS");
              output = output.join("");
            } else {
              output = output + space + "BPS";
            }
            return output;
          },
          unformat: function(string) {
            return +(numeral2._.stringToNumber(string) * 1e-4).toFixed(15);
          }
        });
      })();
      (function() {
        var decimal = {
          base: 1e3,
          suffixes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
        }, binary = {
          base: 1024,
          suffixes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
        };
        var allSuffixes = decimal.suffixes.concat(binary.suffixes.filter(function(item) {
          return decimal.suffixes.indexOf(item) < 0;
        }));
        var unformatRegex = allSuffixes.join("|");
        unformatRegex = "(" + unformatRegex.replace("B", "B(?!PS)") + ")";
        numeral2.register("format", "bytes", {
          regexps: {
            format: /([0\s]i?b)/,
            unformat: new RegExp(unformatRegex)
          },
          format: function(value, format, roundingFunction) {
            var output, bytes = numeral2._.includes(format, "ib") ? binary : decimal, suffix = numeral2._.includes(format, " b") || numeral2._.includes(format, " ib") ? " " : "", power, min, max;
            format = format.replace(/\s?i?b/, "");
            for (power = 0; power <= bytes.suffixes.length; power++) {
              min = Math.pow(bytes.base, power);
              max = Math.pow(bytes.base, power + 1);
              if (value === null || value === 0 || value >= min && value < max) {
                suffix += bytes.suffixes[power];
                if (min > 0) {
                  value = value / min;
                }
                break;
              }
            }
            output = numeral2._.numberToFormat(value, format, roundingFunction);
            return output + suffix;
          },
          unformat: function(string) {
            var value = numeral2._.stringToNumber(string), power, bytesMultiplier;
            if (value) {
              for (power = decimal.suffixes.length - 1; power >= 0; power--) {
                if (numeral2._.includes(string, decimal.suffixes[power])) {
                  bytesMultiplier = Math.pow(decimal.base, power);
                  break;
                }
                if (numeral2._.includes(string, binary.suffixes[power])) {
                  bytesMultiplier = Math.pow(binary.base, power);
                  break;
                }
              }
              value *= bytesMultiplier || 1;
            }
            return value;
          }
        });
      })();
      (function() {
        numeral2.register("format", "currency", {
          regexps: {
            format: /(\$)/
          },
          format: function(value, format, roundingFunction) {
            var locale = numeral2.locales[numeral2.options.currentLocale], symbols = {
              before: format.match(/^([\+|\-|\(|\s|\$]*)/)[0],
              after: format.match(/([\+|\-|\)|\s|\$]*)$/)[0]
            }, output, symbol, i;
            format = format.replace(/\s?\$\s?/, "");
            output = numeral2._.numberToFormat(value, format, roundingFunction);
            if (value >= 0) {
              symbols.before = symbols.before.replace(/[\-\(]/, "");
              symbols.after = symbols.after.replace(/[\-\)]/, "");
            } else if (value < 0 && (!numeral2._.includes(symbols.before, "-") && !numeral2._.includes(symbols.before, "("))) {
              symbols.before = "-" + symbols.before;
            }
            for (i = 0; i < symbols.before.length; i++) {
              symbol = symbols.before[i];
              switch (symbol) {
                case "$":
                  output = numeral2._.insert(output, locale.currency.symbol, i);
                  break;
                case " ":
                  output = numeral2._.insert(output, " ", i + locale.currency.symbol.length - 1);
                  break;
              }
            }
            for (i = symbols.after.length - 1; i >= 0; i--) {
              symbol = symbols.after[i];
              switch (symbol) {
                case "$":
                  output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral2._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));
                  break;
                case " ":
                  output = i === symbols.after.length - 1 ? output + " " : numeral2._.insert(output, " ", -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));
                  break;
              }
            }
            return output;
          }
        });
      })();
      (function() {
        numeral2.register("format", "exponential", {
          regexps: {
            format: /(e\+|e-)/,
            unformat: /(e\+|e-)/
          },
          format: function(value, format, roundingFunction) {
            var output, exponential = typeof value === "number" && !numeral2._.isNaN(value) ? value.toExponential() : "0e+0", parts = exponential.split("e");
            format = format.replace(/e[\+|\-]{1}0/, "");
            output = numeral2._.numberToFormat(Number(parts[0]), format, roundingFunction);
            return output + "e" + parts[1];
          },
          unformat: function(string) {
            var parts = numeral2._.includes(string, "e+") ? string.split("e+") : string.split("e-"), value = Number(parts[0]), power = Number(parts[1]);
            power = numeral2._.includes(string, "e-") ? power *= -1 : power;
            function cback(accum, curr, currI, O) {
              var corrFactor = numeral2._.correctionFactor(accum, curr), num = accum * corrFactor * (curr * corrFactor) / (corrFactor * corrFactor);
              return num;
            }
            return numeral2._.reduce([value, Math.pow(10, power)], cback, 1);
          }
        });
      })();
      (function() {
        numeral2.register("format", "ordinal", {
          regexps: {
            format: /(o)/
          },
          format: function(value, format, roundingFunction) {
            var locale = numeral2.locales[numeral2.options.currentLocale], output, ordinal = numeral2._.includes(format, " o") ? " " : "";
            format = format.replace(/\s?o/, "");
            ordinal += locale.ordinal(value);
            output = numeral2._.numberToFormat(value, format, roundingFunction);
            return output + ordinal;
          }
        });
      })();
      (function() {
        numeral2.register("format", "percentage", {
          regexps: {
            format: /(%)/,
            unformat: /(%)/
          },
          format: function(value, format, roundingFunction) {
            var space = numeral2._.includes(format, " %") ? " " : "", output;
            if (numeral2.options.scalePercentBy100) {
              value = value * 100;
            }
            format = format.replace(/\s?\%/, "");
            output = numeral2._.numberToFormat(value, format, roundingFunction);
            if (numeral2._.includes(output, ")")) {
              output = output.split("");
              output.splice(-1, 0, space + "%");
              output = output.join("");
            } else {
              output = output + space + "%";
            }
            return output;
          },
          unformat: function(string) {
            var number = numeral2._.stringToNumber(string);
            if (numeral2.options.scalePercentBy100) {
              return number * 0.01;
            }
            return number;
          }
        });
      })();
      (function() {
        numeral2.register("format", "time", {
          regexps: {
            format: /(:)/,
            unformat: /(:)/
          },
          format: function(value, format, roundingFunction) {
            var hours = Math.floor(value / 60 / 60), minutes = Math.floor((value - hours * 60 * 60) / 60), seconds = Math.round(value - hours * 60 * 60 - minutes * 60);
            return hours + ":" + (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
          },
          unformat: function(string) {
            var timeArray = string.split(":"), seconds = 0;
            if (timeArray.length === 3) {
              seconds = seconds + Number(timeArray[0]) * 60 * 60;
              seconds = seconds + Number(timeArray[1]) * 60;
              seconds = seconds + Number(timeArray[2]);
            } else if (timeArray.length === 2) {
              seconds = seconds + Number(timeArray[0]) * 60;
              seconds = seconds + Number(timeArray[1]);
            }
            return Number(seconds);
          }
        });
      })();
      return numeral2;
    });
  }
});

// main.ts
__export(exports, {
  CRYPTONATOR_API: () => CRYPTONATOR_API,
  default: () => CryptoLookup
});
var import_obsidian2 = __toModule(require("obsidian"));
var import_numeral = __toModule(require_numeral());

// crypto-modal.ts
var import_obsidian = __toModule(require("obsidian"));
var CryptoModal = class extends import_obsidian.Modal {
  constructor(app, defaultTarget, onSubmit) {
    super(app);
    this.target = defaultTarget;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Select crypto base and target" });
    new import_obsidian.Setting(contentEl).setName("Base").addText((text) => text.setValue(this.base).onChange((value) => {
      this.base = value;
    }));
    new import_obsidian.Setting(contentEl).setName("Target").addText((text) => text.setValue(this.target).onChange((value) => {
      this.target = value;
    }));
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Lookup").setCta().onClick(() => {
      this.close();
      this.onSubmit(this.base, this.target);
    }));
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var CRYPTONATOR_API = "https://api.cryptonator.com/api";
var DEFAULT_SETTINGS = {
  defaultBase: "BTC",
  defaultTarget: "USD"
};
var CryptoLookup = class extends import_obsidian2.Plugin {
  getCurrencyTicker(base, target) {
    return __async(this, null, function* () {
      const data = yield (0, import_obsidian2.request)({
        url: `${CRYPTONATOR_API}/ticker/${base}-${target}`
      });
      return JSON.parse(data);
    });
  }
  getCurrencyListAsJson() {
    return __async(this, null, function* () {
      return yield (0, import_obsidian2.request)({
        url: `${CRYPTONATOR_API}/currencies`
      });
    });
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      const adapter = this.app.vault.adapter;
      const dir = this.manifest.dir;
      yield (() => __async(this, null, function* () {
        const path = (0, import_obsidian2.normalizePath)(`${dir}/currencies.json`);
        if (yield adapter.exists(path)) {
          const currencies = yield adapter.read(path);
          this.currencies = JSON.parse(currencies).rows;
        } else {
          try {
            const currencyText = yield this.getCurrencyListAsJson();
            yield adapter.write(path, currencyText);
            this.currencies = JSON.parse(currencyText).rows;
          } catch (error) {
            const text = "The JSON file could not be read.";
            new import_obsidian2.Notice(text);
            console.error(error);
          }
        }
      }))();
      this.addCommand({
        id: "insert-default-crypto-ticker",
        name: "Insert Default Crypto Ticker",
        editorCallback: (editor) => __async(this, null, function* () {
          if (!this.settings.defaultBase || !this.settings.defaultTarget) {
            new import_obsidian2.Notice("Cannot use this command without default base and target in settings");
          } else {
            const base = this.settings.defaultBase;
            const target = this.settings.defaultTarget;
            const currencyTicker = yield this.getCurrencyTicker(base.toLocaleLowerCase(), target.toLocaleLowerCase());
            const extendedCryptoTicker = `${base}:${target} price = ${(0, import_numeral.default)(currencyTicker.ticker.price).format("0,00.00")}`;
            editor.replaceSelection(extendedCryptoTicker);
          }
        })
      });
      this.addCommand({
        id: "insert-default-crypto-ticker-extended",
        name: "Insert Default Crypto Ticker Extended",
        editorCallback: (editor) => __async(this, null, function* () {
          if (!this.settings.defaultBase || !this.settings.defaultTarget) {
            new import_obsidian2.Notice("Cannot use this command without default base and target in settings");
          } else {
            const base = this.settings.defaultBase;
            const target = this.settings.defaultTarget;
            const currencyTicker = yield this.getCurrencyTicker(base.toLocaleLowerCase(), target.toLocaleLowerCase());
            const formattedTimestamp = window.moment(currencyTicker.timestamp * 1e3).format("YYYY-MM-DDTHH:mm:ss");
            const extendedCryptoTicker = `${base}:${target} price = ${(0, import_numeral.default)(currencyTicker.ticker.price).format("0,00.00")}, volume = ${(0, import_numeral.default)(currencyTicker.ticker.volume).format("0,00.00")}, change = ${(0, import_numeral.default)(currencyTicker.ticker.change).format("0,00.00")} on ${formattedTimestamp}`;
            editor.replaceSelection(extendedCryptoTicker);
          }
        })
      });
      this.addCommand({
        id: "insert-selected-crypto-ticker",
        name: "Insert Selected Crypto Ticker",
        editorCallback: (editor) => __async(this, null, function* () {
          const onSubmit = (base, target) => __async(this, null, function* () {
            const currencyTicker = yield this.getCurrencyTicker(base.toLocaleLowerCase(), target.toLocaleLowerCase());
            const extendedCryptoTicker = `${base}:${target} price = ${(0, import_numeral.default)(currencyTicker.ticker.price).format("0,00.00")}`;
            editor.replaceSelection(extendedCryptoTicker);
          });
          new CryptoModal(this.app, "USD", onSubmit).open();
        })
      });
      this.addCommand({
        id: "insert-selected-crypto-ticker-extended",
        name: "Insert Selected Crypto Ticker Extended",
        editorCallback: (editor) => __async(this, null, function* () {
          const onSubmit = (base, target) => __async(this, null, function* () {
            const currencyTicker = yield this.getCurrencyTicker(base.toLocaleLowerCase(), target.toLocaleLowerCase());
            const formattedTimestamp = window.moment(currencyTicker.timestamp * 1e3).format("YYYY-MM-DDTHH:mm:ss");
            const extendedCryptoTicker = `${base}:${target} price = ${(0, import_numeral.default)(currencyTicker.ticker.price).format("0,00.00")}, volume = ${(0, import_numeral.default)(currencyTicker.ticker.volume).format("0,00.00")}, change = ${(0, import_numeral.default)(currencyTicker.ticker.change).format("0,00.00")} on ${formattedTimestamp}`;
            editor.replaceSelection(extendedCryptoTicker);
          });
          new CryptoModal(this.app, "USD", onSubmit).open();
        })
      });
      this.addSettingTab(new CryptoLookupSettingTab(this.app, this));
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
var CryptoLookupSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Crypto Lookup Defaults" });
    new import_obsidian2.Setting(containerEl).setName("Base Currency").setDesc("Default currency we want the price of").addText((text) => text.setPlaceholder("BTC").setValue(this.plugin.settings.defaultBase).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.defaultBase = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(containerEl).setName("Target Currency").setDesc("Default target currency to convert base currency into").addText((text) => text.setPlaceholder("USD").setValue(this.plugin.settings.defaultTarget).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.defaultTarget = value;
      yield this.plugin.saveSettings();
    })));
  }
};
/*! @preserve
 * numeral.js
 * version : 2.0.6
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */
